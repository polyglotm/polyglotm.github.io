---
layout: post
title: SICP Exercise 1.5 / SICP 연습문제 1.5
date: '2015-08-03T06:15:00.008-07:00'
author: Jaeyoung Lee
tags:
- SICP_part_1
modified_time: '2015-08-03T06:15:57.312-07:00'
blogger_id: tag:blogger.com,1999:blog-5872989675159532416.post-7417618449234211771
blogger_orig_url: http://polyglot-m.blogspot.com/2015/08/sicp-exercise-15-sicp-15.html
---

<span style="color: blue;">Exercise 1.5. Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:</span><br /><br />연습문제 1.5 Bent Bitdiddle은 언어 실행기가 인자 먼저 계산법(applicative order evaluation)을 따르는지 아니면 정의대로 계산법(nomal-order evaluation)을 따르는지 알아보고 싶어서 아래와 같이 두 프로시저를 정의하였다.<br /><br />(define (p) (p))<br /><br />(define (test x y)<br />(if (= x 0)<br />&nbsp; 0<br />&nbsp; y))<br /><br /><span style="color: blue;">Then he evaluates the expression</span><br />그런 다음에 아래 식의 값을 구해 보았다.<br /><br />(test 0 (p))<br /><br /><br /><span style="color: blue;">What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)</span><br /><br />인자 먼저 계산하는 실행기(applicative order evaluation)를 쓴다면 어떤 결과를 보게될까? 정의한 대로 계산하는 실행기(nommal-order evaluation)라면 어떤 결과가 나올까? 저마다 왜 그런 답이 나오는지 밝혀 보라(if 식을 계산하는 규칙은 applicative order나 nomal-order나 같다고 하자. 다시 말해서, 술어의 답, 곧 참이냐 거짓이냐에 따라 두 식 가운데 하나만 골라서 값을 구한다.)<br /><br /><br />---------------------------------------------------------------------------------------------------<br />---------------------------------------------------------------------------------------------------<br /><span style="color: blue;">first Applicative order evaluation case</span><br /><span style="color: blue;"><br /></span><span style="color: blue;">If (test 0 (p)) is executed to compute the launcher (p) to factor calculated first.</span><br /><span style="color: blue;">(p) is (define (p) (p)) is a recursive form because it is.</span><br /><span style="color: blue;">That function is called test does not run (p) is infinite loop.</span><br /><br />첫번째로 인자 먼저 계산하는 실행기(applicative orer evaluation)의 경우<br /><br />(test 0 (p)) 이 실행될경우 인자먼저 계산하는 실행기는 (p)를 연산합니다.<br />(p)는 (define (p) (p))이기 때문에 재귀 호출 형태입니다.<br />즉 test라는 function은 실행 되지 못하고 (p)무한 루프에 빠지게 됩니다.<br /><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><br /><br /><br /><span style="color: blue;">For the second launcher to calculate, as defined in (nomal-order evaluation)</span><br /><span style="color: blue;"><br /></span><span style="color: blue;">(test 0 (p)) When you run the applicative order and now you do not need to immediately run contrary argument does not count.</span><br /><br />두번째로 정의대로 계산하는 실행기(nomal-order evaluation)의 경우<br /><br />(test 0 (p)) 를 실행하면 applicative order와 반대로 당장 필요하지 않은 인자는 계산하지 않고 바로 실행합니다.<br /><br />(define (test x y)<br />(if (= x 0)<br />&nbsp; 0<br />&nbsp; y))<br /><br /><span style="color: blue;">Where x is discarded immediately without is true because 0 and y is OK.</span><br /><span style="color: blue;">So the result is 0.</span><br />여기서 x는 0이기 때문에 true가 되고 y는 확인하지 않고 바로 버려집니다.<br />그래서 결과는 0이 됩니다.<br /><br /><br />